import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../../core/config/supabase_config.dart';
import '../models/addon.dart';

part 'addon_service.g.dart';

@riverpod
AddonService addonService(AddonServiceRef ref) {
  return AddonService();
}

class AddonService {
  final _client = SupabaseConfig.client;

  // Get all add-ons for the current vendor
  Future<List<Addon>> getVendorAddons() async {
    try {
      print('ğŸ” DEBUG: Fetching vendor add-ons');
      
      // Get current vendor ID first
      final vendorId = await _getCurrentVendorId();
      print('ğŸ” DEBUG: Current vendor ID: $vendorId');
      
      final response = await _client
          .from('add_ons')
          .select('*')
          .eq('vendor_id', vendorId)
          .order('created_at', ascending: false);

      print('ğŸ” DEBUG: Add-ons response: $response');

      if (response.isEmpty) {
        return [];
      }

      return response
          .map<Addon>((data) => Addon.fromJson(data))
          .toList();
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to fetch vendor add-ons: $e');
      rethrow;
    }
  }

  // Get add-ons by category
  Future<List<Addon>> getAddonsByCategory(String category) async {
    try {
      print('ğŸ” DEBUG: Fetching add-ons for category: $category');
      
      final response = await _client
          .from('add_ons')
          .select('*')
          .eq('category', category)
          .eq('is_active', true)
          .order('name', ascending: true);

      print('ğŸ” DEBUG: Category add-ons response: $response');

      if (response.isEmpty) {
        return [];
      }

      return response
          .map<Addon>((data) => Addon.fromJson(data))
          .toList();
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to fetch add-ons by category: $e');
      rethrow;
    }
  }

  // Create a new add-on
  Future<Addon> createAddon(Addon addon) async {
    try {
      final addonData = addon.toJson();
      
      // Remove fields that should not be sent on creation (auto-generated by DB)
      addonData.remove('id');
      addonData.remove('created_at');
      addonData.remove('updated_at');
      
      // Get vendor ID from the current user
      final vendorId = await _getCurrentVendorId();
      addonData['vendor_id'] = vendorId;
      
      print('ğŸ” DEBUG: Creating add-on: $addonData');
      
      final response = await _client
          .from('add_ons')
          .insert(addonData)
          .select()
          .single();

      print('ğŸ” DEBUG: Created add-on response: $response');
      return Addon.fromJson(response);
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to create add-on: $e');
      rethrow;
    }
  }

  // Update add-on
  Future<Addon> updateAddon(String addonId, Map<String, dynamic> updates) async {
    try {
      print('ğŸ” DEBUG: Updating add-on $addonId with: $updates');
      
      final response = await _client
          .from('add_ons')
          .update(updates)
          .eq('id', addonId)
          .select()
          .single();

      print('ğŸ” DEBUG: Updated add-on response: $response');
      return Addon.fromJson(response);
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to update add-on: $e');
      rethrow;
    }
  }

  // Delete add-on
  Future<void> deleteAddon(String addonId) async {
    try {
      print('ğŸ” DEBUG: Deleting add-on: $addonId');
      
      await _client
          .from('add_ons')
          .delete()
          .eq('id', addonId);

      print('ğŸ” DEBUG: Add-on deleted successfully');
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to delete add-on: $e');
      rethrow;
    }
  }

  // Toggle add-on active status
  Future<Addon> toggleAddonStatus(String addonId, bool isActive) async {
    try {
      return await updateAddon(addonId, {'is_active': isActive});
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to toggle add-on status: $e');
      rethrow;
    }
  }

  // Get available categories
  Future<List<String>> getAvailableCategories() async {
    try {
      // Return predefined categories instead of querying database
      // This ensures categories are always available even for new vendors
      final predefinedCategories = [
        'cake',
        'special service', 
        'extra-special-service',
        'cakes',
      ];
      
      // Also fetch any custom categories from the database
      final response = await _client
          .from('add_ons')
          .select('category')
          .not('category', 'is', null);

      final dbCategories = response
          .map<String>((data) => (data['category'] as String?) ?? '')
          .where((category) => category.isNotEmpty && !predefinedCategories.contains(category))
          .toSet()
          .toList();
      
      // Combine predefined and database categories
      final allCategories = [...predefinedCategories, ...dbCategories];
      allCategories.sort();
      return allCategories;
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to fetch categories: $e');
      // Return predefined categories as fallback
      return [
        'cake',
        'special service',
        'extra-special-service', 
        'cakes',
      ];
    }
  }

  // Helper method to get current vendor ID
  Future<String> _getCurrentVendorId() async {
    try {
      final user = _client.auth.currentUser;
      if (user == null) {
        throw Exception('User not authenticated');
      }

      final response = await _client
          .from('vendors')
          .select('id')
          .eq('auth_user_id', user.id)
          .single();

      return response['id'] as String;
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to get vendor ID: $e');
      rethrow;
    }
  }
}