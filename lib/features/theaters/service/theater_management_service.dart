import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../../core/config/supabase_config.dart';
import '../models/private_theater.dart';
import '../models/theater_screen.dart';

part 'theater_management_service.g.dart';

@riverpod
TheaterManagementService theaterManagementService(TheaterManagementServiceRef ref) {
  return TheaterManagementService();
}

class TheaterManagementService {
  final _client = SupabaseConfig.client;

  // Get all theaters for a vendor
  Future<List<PrivateTheater>> getVendorTheaters(String vendorId) async {
    try {
      print('ğŸ” DEBUG: Fetching theaters for vendor: $vendorId');
      
      final response = await _client
          .from('private_theaters')
          .select('*')
          .eq('owner_id', vendorId)
          .order('created_at', ascending: false);

      print('ğŸ” DEBUG: Theaters response: $response');

      if (response.isEmpty) {
        return [];
      }

      return response
          .map<PrivateTheater>((data) => PrivateTheater.fromJson(data))
          .toList();
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to fetch vendor theaters: $e');
      rethrow;
    }
  }

  // Get theater screens count
  Future<int> getTheaterScreensCount(String theaterId) async {
    try {
      final response = await _client
          .from('theater_screens')
          .select('id')
          .eq('theater_id', theaterId);

      return response.length;
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to get theater screens count: $e');
      return 0;
    }
  }

  // Get theater screens for a specific theater
  Future<List<TheaterScreen>> getTheaterScreens(String theaterId) async {
    try {
      print('ğŸ” DEBUG: Fetching screens for theater: $theaterId');
      
      final response = await _client
          .from('theater_screens')
          .select('*')
          .eq('theater_id', theaterId)
          .order('screen_number', ascending: true);

      print('ğŸ” DEBUG: Screens response: $response');

      if (response.isEmpty) {
        return [];
      }

      return response
          .map<TheaterScreen>((data) => TheaterScreen.fromJson(data))
          .toList();
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to fetch theater screens: $e');
      rethrow;
    }
  }

  // Add a new screen to theater
  Future<TheaterScreen> addTheaterScreen(TheaterScreen screen) async {
    try {
      final screenData = screen.toJson();
      
      // Remove fields that should not be sent on creation (auto-generated by DB)
      screenData.remove('id');
      screenData.remove('created_at');
      screenData.remove('updated_at');
      
      print('ğŸ” DEBUG: Adding screen: $screenData');
      
      final response = await _client
          .from('theater_screens')
          .insert(screenData)
          .select()
          .single();

      print('ğŸ” DEBUG: Added screen response: $response');
      return TheaterScreen.fromJson(response);
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to add theater screen: $e');
      rethrow;
    }
  }

  // Update theater screen
  Future<TheaterScreen> updateTheaterScreen(String screenId, Map<String, dynamic> updates) async {
    try {
      print('ğŸ” DEBUG: Updating screen $screenId with: $updates');
      
      final response = await _client
          .from('theater_screens')
          .update(updates)
          .eq('id', screenId)
          .select()
          .single();

      print('ğŸ” DEBUG: Updated screen response: $response');
      return TheaterScreen.fromJson(response);
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to update theater screen: $e');
      rethrow;
    }
  }

  // Delete theater screen
  Future<void> deleteTheaterScreen(String screenId) async {
    try {
      print('ğŸ” DEBUG: Deleting screen: $screenId');
      
      await _client
          .from('theater_screens')
          .delete()
          .eq('id', screenId);

      print('ğŸ” DEBUG: Screen deleted successfully');
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to delete theater screen: $e');
      rethrow;
    }
  }

  // Delete theater (with all screens)
  Future<void> deleteTheater(String theaterId) async {
    try {
      print('ğŸ” DEBUG: Deleting theater: $theaterId');
      
      // First delete all screens
      await _client
          .from('theater_screens')
          .delete()
          .eq('theater_id', theaterId);

      // Then delete theater
      await _client
          .from('private_theaters')
          .delete()
          .eq('id', theaterId);

      print('ğŸ” DEBUG: Theater deleted successfully');
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to delete theater: $e');
      rethrow;
    }
  }

  // Get theater by ID
  Future<PrivateTheater?> getTheaterById(String theaterId) async {
    try {
      print('ğŸ” DEBUG: Fetching theater by ID: $theaterId');
      
      final response = await _client
          .from('private_theaters')
          .select('*')
          .eq('id', theaterId)
          .maybeSingle();

      if (response == null) {
        return null;
      }

      return PrivateTheater.fromJson(response);
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to fetch theater by ID: $e');
      rethrow;
    }
  }

  // Get next available screen number for a theater
  Future<int> getNextAvailableScreenNumber(String theaterId) async {
    try {
      print('ğŸ” DEBUG: Getting next available screen number for theater: $theaterId');
      
      final response = await _client
          .from('theater_screens')
          .select('screen_number')
          .eq('theater_id', theaterId)
          .order('screen_number', ascending: true);

      print('ğŸ” DEBUG: Existing screen numbers: $response');

      if (response.isEmpty) {
        print('ğŸ” DEBUG: No existing screens, returning 1');
        return 1; // First screen
      }

      // Get all screen numbers and find the first gap or next number
      final existingNumbers = response
          .map<int>((row) => row['screen_number'] as int)
          .toSet();

      print('ğŸ” DEBUG: Existing screen numbers set: $existingNumbers');

      // Find the first available number starting from 1
      int nextNumber = 1;
      while (existingNumbers.contains(nextNumber)) {
        nextNumber++;
      }

      print('ğŸ” DEBUG: Next available screen number: $nextNumber');
      return nextNumber;
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to get next available screen number: $e');
      return 1; // Default to 1 on error
    }
  }

  // Check if screen number exists for theater
  Future<bool> isScreenNumberExists(String theaterId, int screenNumber, {String? excludeScreenId}) async {
    try {
      print('ğŸ” DEBUG: Checking if screen number $screenNumber exists for theater $theaterId');
      print('ğŸ” DEBUG: Excluding screen ID: $excludeScreenId');
      
      var query = _client
          .from('theater_screens')
          .select('id, screen_number')
          .eq('theater_id', theaterId)
          .eq('screen_number', screenNumber);

      // Exclude current screen when editing
      if (excludeScreenId != null) {
        query = query.neq('id', excludeScreenId);
      }

      final response = await query.maybeSingle();
      print('ğŸ” DEBUG: Screen existence check response: $response');
      
      final exists = response != null;
      print('ğŸ” DEBUG: Screen number $screenNumber exists: $exists');
      return exists;
    } catch (e) {
      print('ğŸ”´ ERROR: Failed to check screen number existence: $e');
      return false;
    }
  }
}