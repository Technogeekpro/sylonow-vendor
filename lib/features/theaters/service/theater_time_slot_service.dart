import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../../core/config/supabase_config.dart';
import '../models/theater_time_slot.dart';

part 'theater_time_slot_service.g.dart';

@riverpod
TheaterTimeSlotService theaterTimeSlotService(TheaterTimeSlotServiceRef ref) {
  return TheaterTimeSlotService();
}

class TheaterTimeSlotService {
  final _client = SupabaseConfig.client;

  // Get time slots for a specific theater screen
  Future<List<TheaterTimeSlot>> getScreenTimeSlots(String screenId) async {
    try {
      print('üîç DEBUG: Fetching time slots for screen: $screenId');
      
      final response = await _client
          .from('theater_time_slots')
          .select('*')
          .eq('screen_id', screenId)
          .eq('is_active', true)
          .order('start_time', ascending: true);

      print('üîç DEBUG: Time slots response: $response');

      if (response.isEmpty) {
        return [];
      }

      return response
          .map<TheaterTimeSlot>((data) => TheaterTimeSlot.fromJson(data))
          .toList();
    } catch (e) {
      print('üî¥ ERROR: Failed to fetch time slots: $e');
      rethrow;
    }
  }

  // Get time slots for a specific theater (all screens)
  Future<List<TheaterTimeSlot>> getTheaterTimeSlots(String theaterId) async {
    try {
      print('üîç DEBUG: Fetching time slots for theater: $theaterId');
      
      final response = await _client
          .from('theater_time_slots')
          .select('*')
          .eq('theater_id', theaterId)
          .eq('is_active', true)
          .order('start_time', ascending: true);

      print('üîç DEBUG: Theater time slots response: $response');

      if (response.isEmpty) {
        return [];
      }

      return response
          .map<TheaterTimeSlot>((data) => TheaterTimeSlot.fromJson(data))
          .toList();
    } catch (e) {
      print('üî¥ ERROR: Failed to fetch theater time slots: $e');
      rethrow;
    }
  }

  // Create a new time slot
  Future<TheaterTimeSlot> createTimeSlot(TheaterTimeSlot timeSlot) async {
    try {
      final slotData = timeSlot.toJson();
      
      // Remove fields that should not be sent on creation (auto-generated by DB)
      slotData.remove('id');
      slotData.remove('created_at');
      slotData.remove('updated_at');
      
      print('üîç DEBUG: Creating time slot: $slotData');
      
      final response = await _client
          .from('theater_time_slots')
          .insert(slotData)
          .select()
          .single();

      print('üîç DEBUG: Created time slot response: $response');
      return TheaterTimeSlot.fromJson(response);
    } catch (e) {
      print('üî¥ ERROR: Failed to create time slot: $e');
      rethrow;
    }
  }

  // Update time slot
  Future<TheaterTimeSlot> updateTimeSlot(String slotId, Map<String, dynamic> updates) async {
    try {
      print('üîç DEBUG: Updating time slot $slotId with: $updates');
      
      final response = await _client
          .from('theater_time_slots')
          .update(updates)
          .eq('id', slotId)
          .select()
          .single();

      print('üîç DEBUG: Updated time slot response: $response');
      return TheaterTimeSlot.fromJson(response);
    } catch (e) {
      print('üî¥ ERROR: Failed to update time slot: $e');
      rethrow;
    }
  }

  // Delete time slot
  Future<void> deleteTimeSlot(String slotId) async {
    try {
      print('üîç DEBUG: Deleting time slot: $slotId');
      
      await _client
          .from('theater_time_slots')
          .delete()
          .eq('id', slotId);

      print('üîç DEBUG: Time slot deleted successfully');
    } catch (e) {
      print('üî¥ ERROR: Failed to delete time slot: $e');
      rethrow;
    }
  }

  // Toggle time slot availability
  Future<TheaterTimeSlot> toggleSlotAvailability(String slotId, bool isAvailable) async {
    try {
      return await updateTimeSlot(slotId, {'is_available': isAvailable});
    } catch (e) {
      print('üî¥ ERROR: Failed to toggle slot availability: $e');
      rethrow;
    }
  }

  // Get all available time slots for a screen (recurring slots)
  Future<List<TheaterTimeSlot>> getAvailableSlots({
    required String screenId,
  }) async {
    try {
      print('üîç DEBUG: Fetching available slots for screen $screenId');
      
      final response = await _client
          .from('theater_time_slots')
          .select('*')
          .eq('screen_id', screenId)
          .eq('is_available', true)
          .eq('is_active', true)
          .order('start_time', ascending: true);

      print('üîç DEBUG: Available slots response: $response');

      if (response.isEmpty) {
        return [];
      }

      return response
          .map<TheaterTimeSlot>((data) => TheaterTimeSlot.fromJson(data))
          .toList();
    } catch (e) {
      print('üî¥ ERROR: Failed to fetch available slots: $e');
      rethrow;
    }
  }

  // Mark time slot as booked for a specific date
  Future<void> markSlotAsBooked(String slotId, DateTime date) async {
    try {
      print('üîç DEBUG: Marking slot $slotId as booked for date: $date');
      
      final bookingData = {
        'time_slot_id': slotId,
        'booked_date': date.toIso8601String().split('T')[0], // Format as YYYY-MM-DD
      };
      
      await _client
          .from('theater_time_slot_bookings')
          .insert(bookingData);

      print('üîç DEBUG: Time slot marked as booked successfully');
    } catch (e) {
      print('üî¥ ERROR: Failed to mark slot as booked: $e');
      rethrow;
    }
  }

  // Remove booking for a time slot (unmark as booked)
  Future<void> unmarkSlotAsBooked(String slotId) async {
    try {
      print('üîç DEBUG: Removing booking for slot: $slotId');
      
      await _client
          .from('theater_time_slot_bookings')
          .delete()
          .eq('time_slot_id', slotId);

      print('üîç DEBUG: Booking removed successfully');
    } catch (e) {
      print('üî¥ ERROR: Failed to remove booking: $e');
      rethrow;
    }
  }

  // Remove booking for a time slot on a specific date
  Future<void> unmarkSlotAsBookedForDate(String slotId, DateTime date) async {
    try {
      print('üîç DEBUG: Removing booking for slot $slotId on date: $date');
      final dateStr = date.toIso8601String().split('T')[0];
      
      // Remove from theater_time_slot_bookings table
      await _client
          .from('theater_time_slot_bookings')
          .delete()
          .eq('time_slot_id', slotId)
          .eq('booked_date', dateStr);

      // Note: We don't delete from private_theater_bookings as those are actual customer bookings
      // and should only be cancelled through proper booking management, not through time slot management
      
      print('üîç DEBUG: Booking removed successfully for specific date');
    } catch (e) {
      print('üî¥ ERROR: Failed to remove booking for date: $e');
      rethrow;
    }
  }

  // Check if a time slot is booked for a specific date
  Future<bool> isSlotBookedForDate(String slotId, DateTime date) async {
    try {
      final dateStr = date.toIso8601String().split('T')[0];
      
      // Check theater_time_slot_bookings table
      final timeSlotBookingResponse = await _client
          .from('theater_time_slot_bookings')
          .select('id')
          .eq('time_slot_id', slotId)
          .eq('booked_date', dateStr)
          .maybeSingle();

      if (timeSlotBookingResponse != null) {
        return true;
      }

      // Check private_theater_bookings table
      final privateBookingResponse = await _client
          .from('private_theater_bookings')
          .select('id')
          .eq('time_slot_id', slotId)
          .eq('booking_date', dateStr)
          .neq('booking_status', 'cancelled') // Exclude cancelled bookings
          .maybeSingle();

      return privateBookingResponse != null;
    } catch (e) {
      print('üî¥ ERROR: Failed to check if slot is booked: $e');
      return false;
    }
  }

  // Get all booked dates for a time slot
  Future<List<DateTime>> getBookedDatesForSlot(String slotId) async {
    try {
      final Set<DateTime> bookedDates = {};

      // Get dates from theater_time_slot_bookings table
      final timeSlotBookingsResponse = await _client
          .from('theater_time_slot_bookings')
          .select('booked_date')
          .eq('time_slot_id', slotId)
          .order('booked_date', ascending: true);

      for (final data in timeSlotBookingsResponse) {
        bookedDates.add(DateTime.parse(data['booked_date']));
      }

      // Get dates from private_theater_bookings table
      final privateBookingsResponse = await _client
          .from('private_theater_bookings')
          .select('booking_date')
          .eq('time_slot_id', slotId)
          .neq('booking_status', 'cancelled') // Exclude cancelled bookings
          .order('booking_date', ascending: true);

      for (final data in privateBookingsResponse) {
        bookedDates.add(DateTime.parse(data['booking_date']));
      }

      // Return sorted list of unique dates
      final sortedDates = bookedDates.toList()..sort();
      return sortedDates;
    } catch (e) {
      print('üî¥ ERROR: Failed to get booked dates: $e');
      return [];
    }
  }

  // Get detailed booking information for a time slot on a specific date
  Future<Map<String, dynamic>?> getBookingDetailsForSlotAndDate(String slotId, DateTime date) async {
    try {
      final dateStr = date.toIso8601String().split('T')[0];
      
      // Check theater_time_slot_bookings table first (vendor-marked bookings)
      final timeSlotBookingResponse = await _client
          .from('theater_time_slot_bookings')
          .select('*')
          .eq('time_slot_id', slotId)
          .eq('booked_date', dateStr)
          .maybeSingle();

      if (timeSlotBookingResponse != null) {
        return {
          'type': 'vendor_booking',
          'data': timeSlotBookingResponse,
          'can_unbook': true, // Vendor can remove their own markings
        };
      }

      // Check private_theater_bookings table (customer bookings)
      final privateBookingResponse = await _client
          .from('private_theater_bookings')
          .select('*, user_id')
          .eq('time_slot_id', slotId)
          .eq('booking_date', dateStr)
          .neq('booking_status', 'cancelled')
          .maybeSingle();

      if (privateBookingResponse != null) {
        return {
          'type': 'customer_booking',
          'data': privateBookingResponse,
          'can_unbook': false, // Customer bookings should not be removed from time slot management
          'customer_name': privateBookingResponse['contact_name'],
          'booking_status': privateBookingResponse['booking_status'],
        };
      }

      return null; // No booking found
    } catch (e) {
      print('üî¥ ERROR: Failed to get booking details: $e');
      return null;
    }
  }
}